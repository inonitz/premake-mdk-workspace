#version 450 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout (binding = 0) uniform sampler2D sim_velocity_pressure;
layout (binding = 1) uniform sampler2D sim_forces;
layout (binding = 2, rgba32f) writeonly uniform image2D sim_output;


vec4 textureBilerp(
    in sampler2D tex, 
    in vec2      uv
);

bvec4 isBoundary(ivec2 coords);

vec4 advection_step(
    in ivec2     coord,
    in vec2      normcoord, 
    in sampler2D ufield, 
    in sampler2D quantity_read
);


uniform float ku_dt;
uniform float ku_viscosity;
uniform ivec2 ku_simdims;

vec2 k_unitCoord = vec2(1) / vec2(ku_simdims); 


void main()
{
    ivec2 texelCoord    = ivec2(gl_GlobalInvocationID.xy);
    vec2  norm_texcoord = vec2(texelCoord) * k_unitCoord;
    
    /* not sure if boundary conditions should be placed now or later... */
    if(any(isBoundary(texelCoord)))
        return;
    
    vec4 result = 
        texture(sim_forces, norm_texcoord) 
        + 
        advection_step(
            texelCoord, 
            norm_texcoord, 
            sim_velocity_pressure, 
            sim_velocity_pressure
        );
    imageStore(sim_output, texelCoord, result);
    return;
}




bvec4 isBoundary(ivec2 coords) {
    return bvec4(
        coords.x == 0, 
        coords.y == 0,
        coords.x == (ku_simdims.x - 1),
        coords.y == (ku_simdims.y - 1)
    );
}


// bool apply_boundaries(in ivec2 texCoord, in image2D field) 
// {
//     const vec4  boundaryMultipliers = vec4(-1.0f, -1.0f, 1.0f, 1.0f);
//     const bvec4 boundbits = isBoundary(texCoord);
//     ivec2       texelToFetch = texCoord;

//     texelToFetch += ivec2(boundbits.xy);
//     texelToFetch -= ivec2(boundbits.zw);

//     imageStore(field, texCoord, boundaryMultipliers * vec4(imageLoad(field, texelToFetch)));
//     return any(boundbits);
// }


vec4 textureBilerp(in sampler2D tex, vec2 uv)
{
    vec2 weight = fract(uv);
    vec4 bottom = mix(
        texture(tex, uv + vec2(0,             0)), 
        texture(tex, uv + vec2(k_unitCoord.x, 0)),
        weight.x
    );
    vec4 top    = mix(
        texture(tex, uv + vec2(0,             k_unitCoord.y)), 
        texture(tex, uv + vec2(k_unitCoord.x, k_unitCoord.y)),
        weight.x
    );
    return mix(bottom, top, weight.y);
}


/* 
    I should try to implement an advection step according to the equation,
    instead of explicitly writing what the article suggests;
    considering that I have all the eq ready for it,
    this should be trivial.
    But i'll leave it for later, until I get something working first!!
*/
vec4 advection_step(
    in ivec2     coord,
    in vec2      normcoord, 
    in sampler2D ufield, 
    in sampler2D quantity_read
) {
    vec2 newcoord = normcoord - ku_dt * texture(ufield, normcoord).xy;
    return textureBilerp(quantity_read, newcoord);
}