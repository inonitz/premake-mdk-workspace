#version 450 core
/* 
    more info on why this ext is needed:
    https://github.com/KhronosGroup/GLSL/issues/57
    https://stackoverflow.com/questions/27983936/opengl-layout-informations
    https://registry.khronos.org/OpenGL/extensions/EXT/EXT_shader_image_load_formatted.txt
    Needed for apply_boundaries()
*/
#extension GL_EXT_shader_image_load_formatted : require
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout (binding = 1, rgba32f) writeonly uniform image2D   renderto;
layout (binding = 2)                    uniform sampler2D sim_step_u0;
layout (binding = 3)                    uniform image2D   sim_step_u1;


layout(binding = 7)  uniform image2D component_diffusion;
layout(binding = 8)  uniform image2D component_advection;
layout(binding = 9)  uniform image2D component_externalforce;
layout(binding = 9)  uniform image2D sim_field; /* contains w in .xy & p in .z */
layout(binding = 10) uniform image2D sim_scratch;


// layout (binding = 4)                    uniform sampler2D sim_step_x0;
// layout (binding = 5, rgba32f) writeonly uniform image2D   sim_step_x1;

/* 
    The expected format of the field is:
    field[i].x = u-component of the velocity field
    field[i].y = v-component of the velocity field (this is a 2d simulation)
    field[i].z = scalar-component of the pressure field
    field[i].w = 0;
*/


/* 
    0 = calculating new velocity field, computing its divergence in a diff buffer
    1 = using 0:divergence result to calculate new pressure
    2 = using 1:new pressure and 0:new velocity to calculate final velocity3
    3 = using 2:final velocity and some other advected quantity, like dye or smoke
        rendered to the screen
*/
uniform uint  u_shaderStage;

uniform float ku_dt;
uniform float ku_viscosity;
uniform ivec2 ku_simdims;


vec2 k_unitCoord = vec2(1) / vec2(ku_simdims); 






/* 
    with apply_boundaries() we can't sample from outside the texture,
    and honestly this looks more natural.
    but idk :/
*/
vec4 textureBilerp2(in sampler2D tex, vec2 uv)
{
    vec2 weight = fract(uv);
    vec4 bottom = mix(
        texture(tex, uv - vec2(k_unitCoord.x, 0)), 
        texture(tex, uv + vec2(k_unitCoord.x, 0)),
        weight.x
    );
    vec4 top    = mix(
        texture(tex, uv - vec2(0, k_unitCoord.y)), 
        texture(tex, uv + vec2(0, k_unitCoord.y)),
        weight.x
    );
    return mix(bottom, top, weight.y);
}








void modified_jacobi_solver_velocity(
    in ivec2 ij,
    in float alpha,
    in float inverseBeta,
    in sampler2D x,
    in sampler2D b,
    in image2D __out
) {
    /* 
        single iteration of the jacobi solver.
        this needs to run 40-80 times for accurate results 
        (i'm not using error estimation for exiting the function anytime soon) 
    */
    /* boundary-condition-code might be moved to a different function for uniformity of neighbour-value accesses */
    ivec2 neighbourIndices[4] = ivec2[4](
        ij + ivec2(1, 0),
        ij - ivec2(1, 0),
        ij + ivec2(0, 1),
        ij - ivec2(0, 1)
    );
    vec4 neighbourValues[4] = vec4[4](
        imageLoad(x, neighbourIndices[0]),
        imageLoad(x, neighbourIndices[1]),
        imageLoad(x, neighbourIndices[2]),
        imageLoad(x, neighbourIndices[3])
    );
    vec4 result = vec4(0.0f);
    result += neighbourValues[0] + neighbourValues[1] + neighbourValues[2] + neighbourValues[3];
    result += alpha * imageLoad(b, ij);
    result *= inverseBeta;
    result.zw = vec2(0.0f); /* we're only interested in the x-y components (see note top-of-file) */
    imageStore(x, ij, result);
    return;
}


/* maybe ill combine the functionality later... */
void modified_jacobi_solver_pressure(
    in ivec2 ij,
    in float alpha,
    in float inverseBeta,
    in sampler2D x,
    in float     b,
    in image2D __out
) {
    ivec2 neighbourIndices[4] = ivec2[4](
        ij + ivec2(1, 0),
        ij - ivec2(1, 0),
        ij + ivec2(0, 1),
        ij - ivec2(0, 1)
    );
    vec4 neighbourValues = vec4(
        imageLoad(x, neighbourIndices[0]).z,
        imageLoad(x, neighbourIndices[1]).z,
        imageLoad(x, neighbourIndices[2]).z,
        imageLoad(x, neighbourIndices[3]).z
    );
    float result = 0.0f;
    result += neighbourValues.x + neighbourValues.y + neighbourValues.z + neighbourValues.w;
    result += alpha * b;
    result *= inverseBeta;
    imageStore(x, ij, result);
    return;
}


float FieldDivergence(
    in ivec2     texCoord,
    in vec2      dxdyvec,
    in sampler2D toread
) {
    float __out;
    

    dxdyvec = 0.5f / dxdyvec;
    vec4 neighbourValues = vec4(
        imageLoad(toread, texCoord + ivec2(1, 0)).x,
        imageLoad(toread, texCoord - ivec2(1, 0)).x,
        imageLoad(toread, texCoord + ivec2(0, 1)).y,
        imageLoad(toread, texCoord - ivec2(0, 1)).y
    );


    __out  = (neighbourValues[0] - neighbourValues[1]) * dxdyvec.x;
    __out += (neighbourValues[2] - neighbourValues[3]) * dxdyvec.y;
    return;
}   



void main()
{
    ivec2 texelCoord    = ivec2(gl_GlobalInvocationID.xy);
    vec2  norm_texcoord = vec2(texelCoord) * k_unitCoord;

    /* when shaderStage == 0 => apply_boundaries will be applied. */
    if(u_shaderStage == 0 && apply_boundaries(texelCoord, sim_step_u1))
        return;


    /* [TEST]: performance may be lackluster using a uniform */
    switch(u_shaderStage) {
        case 0: /* calculate all components of w [dx = dy = dl = 1] */
            float u_alpha_param = 1.0f / (ku_viscosity * ku_dt);
            float u_beta_param  = u_alpha_param + 4;
            vec4  keep_pressure_value = vec4(0, 0, texture(sim_step_u0, norm_texcoord).z, 0);
            
            
            advection_step(
                texelCoord, 
                norm_texcoord, 
                sim_step_u0, 
                sim_step_u0, 
                component_advection
            );
            modified_jacobi_solver_velocity(
                texelCoord, 
                u_alpha_param, 
                1.0f / u_beta_param, 
                sim_step_u0, 
                sim_step_u0, 
                component_diffusion
            );

            keep_pressure_value += imageRead(component_externalforces, texelCoord);
            imageStore(component_externalforce, texelCoord, keep_pressure_value);
        break;
        case 1: /* write all components of w to sim_field.xy */
            vec4 advect, diffuse, forces;
            advect  = imageLoad(component_advection, texelCoord);
            diffuse = imageLoad(component_diffusion, texelCoord);
            forces  = imageLoad(component_externalforce, texelCoord);
            imageStore(sim_field, texelCoord, advect + diffuse + forces);
        break;
        case 2: /* i expect sim_step_u0 = sim_field */
            float divwij = FieldDivergence(texelCoord, vec2(1), sim_step_u0);
            modified_jacobi_solver_pressure(
                texelCoord,
                -1.0f,
                0.25f,
                sim_step_u0,
                divwij,
                
            );
        break;
        case 10:
        break;
        case 11:
        break;
        case 12:
        default:
        break;
    }

    imageStore(renderto, texelCoord, imageLoad(sim_step_u1, texelCoord));    
    return;
}