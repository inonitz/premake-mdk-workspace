#version 450 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout (binding = 0)                    uniform sampler2D initialField;
layout (binding = 1, rgba32f) writeonly uniform image2D   outputField;


bvec4 isBoundary(ivec2 coords);


/* 
    Single iteration of a jacobi solver
*/
vec2 laplacian(
    in sampler2D x,
    in ivec2 ij,
    in vec2  xij
);


uniform int   ku_valuesToFetch;
uniform float ku_dt;
uniform float ku_viscosity;
uniform ivec2 ku_simdims;
uniform vec2  ku_simUnitCoord;
vec2 k_unitCoord = vec2(1) / vec2(ku_simdims);
vec2 k_simrdxdysq = 1.0f / (ku_simUnitCoord * ku_simUnitCoord);


int flattenWorkGroupIndex()
{
    uvec3 id   = gl_WorkGroupID;
    uvec3 size = gl_NumWorkGroups;
    return int( id.x + size.x * (id.y + size.y * id.z) );
}


ivec2 getTexelIndex(in int offset)
{
    ivec2 imgsize    = textureSize(initialField, 0);
    int   arrayIndex = ku_valuesToFetch * flattenWorkGroupIndex() + offset;
    return ivec2(arrayIndex / imgsize.x, arrayIndex % imgsize.x);
}


void main()
{
    ivec2 currTexel, texelToFetch; 
    vec2  result, valueij;
    bvec4 boundaryBits;
    for(int i = 0; i < ku_valuesToFetch; ++i)
    {
        currTexel = getTexelIndex(i);
        boundaryBits = isBoundary(currTexel);
        if(not(any(boundaryBits))) {
            valueij = texelFetch(initialField, currTexel, 0).xy;
            result = valueij + ku_viscosity * ku_dt * laplacian(initialField, currTexel, valueij);
        } else { 
            texelToFetch = currTexel + ivec2(boundaryBits.xy) - ivec2(boundaryBits.zw);
            result = -1.0f * texelFetch(initialField, texelToFetch, 0).xy;
        }
        imageStore(outputField, currTexel, vec4(result, 0.0f, 0.0f));
    }
    return;
}


bvec4 isBoundary(ivec2 coords) {
    return bvec4(
        coords.x == 0, 
        coords.y == 0,
        coords.x == (ku_simdims.x - 1),
        coords.y == (ku_simdims.y - 1)
    );
}


// bool applyBoundary(ivec2 texelCoord) {
//     const bvec4 boundbits = isBoundary(texelCoord);
//     ivec2 texelToFetch = texelCoord + ivec2(boundbits.xy) - ivec2(boundbits.zw);

//     const vec4 boundaryMultipliers = vec4(
//         -1.0f + 2.0f * float(all(equal(texelToFetch, texelCoord))), /* if equal then this is not a boundary, keep original value */
//         -1.0f + 2.0f * float(all(equal(texelToFetch, texelCoord))), /* if equal then this is not a boundary, keep original value */
//         1.0f, 
//         1.0f
//     );
//     imageStore(outputField, texelCoord, boundaryMultipliers * texelFetch(initialField, texelToFetch, 0));
//     return any(boundbits);
// }


vec2 laplacian(
    in sampler2D x,
    in ivec2 ij,
    in vec2 xij
) {
    vec2 result = vec2(0.0f);
    vec2 neighbourValues[4] = vec2[4](
        texelFetch(x, ij + ivec2(1, 0), 0).xy,
        texelFetch(x, ij - ivec2(1, 0), 0).xy,
        texelFetch(x, ij + ivec2(0, 1), 0).xy,
        texelFetch(x, ij - ivec2(0, 1), 0).xy
    );

    result += (neighbourValues[0] + neighbourValues[1] - 2.0f * xij) * k_simrdxdysq.y;
    result += (neighbourValues[2] + neighbourValues[3] - 2.0f * xij) * k_simrdxdysq.x;
    return result;
}